<h1 id="문제-분석">문제 분석</h1>

<h2 id="-문제-정보">📋 문제 정보</h2>
<ul>
  <li><strong>문제 번호</strong>: <a href="https://www.acmicpc.net/problem/1043">1043번</a></li>
  <li><strong>문제 제목</strong>: 거짓말</li>
  <li><strong>난이도</strong>: 골드 4</li>
  <li><strong>알고리즘</strong>: 분리집합(Union-Find), 그래프이론</li>
  <li><strong>시간복잡도</strong>: O(n)</li>
  <li><strong>공간복잡도</strong>: O(n)</li>
</ul>

<h2 id="-문제-해결-과정">🤔 문제 해결 과정</h2>

<p>이 문제를 해결하기 위해 다음과 같은 단계로 접근했습니다:</p>

<ol>
  <li><strong>문제 이해</strong>: 주어진 조건과 제약사항 파악
    <ul>
      <li>진실을 아는 사람들이 있고, 이들과 같은 파티에 참석하면 거짓말을 할 수 없음</li>
      <li>파티 참석자들은 서로 연결되어 있다고 볼 수 있음</li>
    </ul>
  </li>
  <li><strong>알고리즘 선택</strong>: 적합한 알고리즘/자료구조 결정
    <ul>
      <li>그룹을 나누는 문제 → Union-Find (분리집합) 사용</li>
    </ul>
  </li>
  <li><strong>구현</strong>: 단계별 코드 작성
    <ul>
      <li>같은 파티 참석자들을 하나의 그룹으로 union</li>
      <li>진실을 아는 사람들의 그룹 확인</li>
      <li>각 파티가 안전한지 검사</li>
    </ul>
  </li>
  <li><strong>최적화</strong>: 시간/공간 복잡도 개선
    <ul>
      <li>경로 압축을 통한 find 연산 최적화</li>
    </ul>
  </li>
</ol>

<h3 id="개발-과정에서의-고민">개발 과정에서의 고민:</h3>
<ul>
  <li>첫 번째 시도 - 실패 (단순 그래프 탐색): 진실을 아는 사람과 연결된 모든 사람을 찾으려 했지만 파티별로 연결관계를 제대로 고려하지 못함</li>
  <li>두 번째 시도 - 실패 (BFS 사용): 파티 단위가 아닌 개인별 연결로만 접근해서 틀림</li>
</ul>

<h2 id="-핵심-아이디어">💡 핵심 아이디어</h2>

<ul>
  <li>Union-Find를 사용하여 같은 파티에 참석한 사람들을 하나의 그룹으로 관리합니다</li>
  <li>진실을 아는 사람들이 속한 그룹을 미리 파악합니다</li>
  <li>각 파티의 참석자 중 한 명이라도 진실을 아는 그룹에 속하면 그 파티에서는 거짓말을 할 수 없습니다</li>
</ul>

<h2 id="-실패한-접근들">❌ 실패한 접근들</h2>

<p>다음과 같은 접근들을 시도했지만 실패했습니다:</p>

<h3 id="시도-1---단순-그래프-탐색">시도 1 - 단순 그래프 탐색</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">visited</span><span class="p">):</span>
    <span class="n">visited</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">start</span><span class="p">]:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
            <span class="nf">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">neighbor</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>실패 이유</strong>: 개인간 직접 연결만 고려하고 파티 단위의 그룹핑을 제대로 처리하지 못함</p>

<h3 id="시도-2---bfs-사용">시도 2 - BFS 사용</h3>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="kn">from</span> <span class="n">collections</span> <span class="kn">import</span> <span class="n">deque</span>
<span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="nf">deque</span><span class="p">([</span><span class="n">start</span><span class="p">])</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nf">set</span><span class="p">([</span><span class="n">start</span><span class="p">])</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="nf">popleft</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">neighbor</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">visited</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
                <span class="n">queue</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">visited</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>실패 이유</strong>: 파티 단위가 아닌 개인별 연결로만 접근해서 틀림</p>

<h2 id="-최종-해결-코드">✅ 최종 해결 코드</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
</pre></td><td class="rouge-code"><pre><span class="kn">import</span> <span class="n">sys</span>
<span class="nb">input</span> <span class="o">=</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">sys</span><span class="p">.</span><span class="n">stdin</span><span class="p">.</span><span class="nf">readline</span><span class="p">().</span><span class="nf">strip</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>  <span class="c1"># 경로 압축
</span>    <span class="k">return</span> <span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="o">=</span> <span class="nf">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">x</span><span class="p">),</span> <span class="nf">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">px</span> <span class="o">==</span> <span class="n">py</span><span class="p">:</span>
        <span class="k">return</span>
    
    <span class="c1"># rank에 따른 union
</span>    <span class="k">if</span> <span class="n">rank</span><span class="p">[</span><span class="n">px</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">rank</span><span class="p">[</span><span class="n">py</span><span class="p">]:</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">px</span><span class="p">]</span> <span class="o">=</span> <span class="n">py</span>
    <span class="k">elif</span> <span class="n">rank</span><span class="p">[</span><span class="n">px</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">rank</span><span class="p">[</span><span class="n">py</span><span class="p">]:</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">py</span><span class="p">]</span> <span class="o">=</span> <span class="n">px</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">parent</span><span class="p">[</span><span class="n">py</span><span class="p">]</span> <span class="o">=</span> <span class="n">px</span>
        <span class="n">rank</span><span class="p">[</span><span class="n">px</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="n">n</span><span class="p">,</span> <span class="n">m</span> <span class="o">=</span> <span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">())</span>
<span class="n">truth_people</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">()))</span>

<span class="k">if</span> <span class="n">truth_people</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># 진실을 아는 사람이 없는 경우
</span>    <span class="nf">print</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="n">truth_people</span> <span class="o">=</span> <span class="n">truth_people</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># 첫 번째는 개수
</span>    
    <span class="c1"># 부모 배열 초기화
</span>    <span class="n">parent</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">rank</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    
    <span class="n">parties</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="n">party</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nf">input</span><span class="p">().</span><span class="nf">split</span><span class="p">()))</span>
        <span class="n">party_people</span> <span class="o">=</span> <span class="n">party</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># 첫 번째는 참석자 수
</span>        <span class="n">parties</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">party_people</span><span class="p">)</span>
        
        <span class="c1"># 같은 파티 참석자들을 union
</span>        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">party_people</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="nf">union</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">party_people</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">party_people</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
    
    <span class="c1"># 진실을 아는 사람들의 그룹 찾기
</span>    <span class="n">truth_groups</span> <span class="o">=</span> <span class="nf">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">person</span> <span class="ow">in</span> <span class="n">truth_people</span><span class="p">:</span>
        <span class="n">truth_groups</span><span class="p">.</span><span class="nf">add</span><span class="p">(</span><span class="nf">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">person</span><span class="p">))</span>
    
    <span class="c1"># 과장할 수 있는 파티 개수 계산
</span>    <span class="n">possible_parties</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">party</span> <span class="ow">in</span> <span class="n">parties</span><span class="p">:</span>
        <span class="n">can_lie</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">person</span> <span class="ow">in</span> <span class="n">party</span><span class="p">:</span>
            <span class="k">if</span> <span class="nf">find</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">person</span><span class="p">)</span> <span class="ow">in</span> <span class="n">truth_groups</span><span class="p">:</span>
                <span class="n">can_lie</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">break</span>
        
        <span class="k">if</span> <span class="n">can_lie</span><span class="p">:</span>
            <span class="n">possible_parties</span> <span class="o">+=</span> <span class="mi">1</span>
    
    <span class="nf">print</span><span class="p">(</span><span class="n">possible_parties</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="-코드-해설">🔍 코드 해설</h2>

<p>코드의 주요 부분을 설명하면:</p>

<ul>
  <li><strong>Union-Find 구현</strong>: <code class="language-plaintext highlighter-rouge"><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>find
</pre></td></tr></tbody></table></code>와 <code class="language-plaintext highlighter-rouge"><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>union
</pre></td></tr></tbody></table></code> 함수로 그룹 관리
    <ul>
      <li>경로 압축을 통해 find 연산을 O(α(n))으로 최적화</li>
      <li>rank를 이용한 union으로 트리 높이 최소화</li>
    </ul>
  </li>
  <li><strong>파티 그룹핑</strong>: 같은 파티 참석자들을 union으로 연결
    <ul>
      <li>연속된 사람들을 union하여 전체가 하나의 그룹이 되도록 함</li>
    </ul>
  </li>
  <li>
    <p><strong>진실 그룹 식별</strong>: 진실을 아는 사람들이 속한 그룹들을 set으로 관리</p>
  </li>
  <li><strong>안전한 파티 검사</strong>: 각 파티 참석자가 진실 그룹에 속하지 않는지 확인</li>
</ul>

<h2 id="-배운-점">📚 배운 점</h2>

<ul>
  <li>Union-Find(분리집합) 알고리즘의 실제 적용 경험</li>
  <li>시간복잡도 O(n)로 효율적인 해결</li>
  <li>그래프의 연결 관계를 그룹 단위로 추상화하는 사고법</li>
  <li>경로 압축과 rank 최적화의 중요성</li>
  <li>문제를 단순화해서 접근하는 방법</li>
</ul>

<h2 id="-관련-문제">🔗 관련 문제</h2>

<p>비슷한 알고리즘을 사용하는 추천 문제들:</p>

<ul>
  <li><strong>[백준 1717번] 집합의 표현</strong>: Union-Find 기본 문제</li>
  <li><strong>[백준 4195번] 친구 네트워크</strong>: Union-Find + 그룹 크기 관리</li>
  <li><strong>[백준 20040번] 사이클 게임</strong>: Union-Find로 사이클 탐지</li>
  <li><strong>[백준 1976번] 여행 가자</strong>: Union-Find로 연결성 확인</li>
</ul>

<hr />
<p><em>이 포스트가 도움되셨나요? 댓글로 피드백 남겨주세요!</em></p>
